using System;
using System.IO;

namespace Mp3FrameShuffler
{
    class Mp3
    {
        public byte[] mp3Bytes = File.ReadAllBytes("E:/Documents/GitHub/ENSE496-Assignment4/Mp3FrameShuffler/mp3.mp3");
        public byte[] frameHeader = new byte[4];
        public int frameLength; //length of frame, minus the header;
        public int numFrames = 0; //frame counter
        public int dataStart = 0;
    }

    class Mp3FrameShuffler
    {
        static void Main(string[] args)
        {
            int key = 5;
            Mp3 mp3 = new Mp3();

            GetMp3Data(mp3);
            byte[][] frames = GetFrameArray(mp3);

            byte[][] shuffledFrames = Shuffle(frames, mp3.numFrames, mp3.frameLength, key);
            byte[][] unshuffledFrames = Unshuffle(shuffledFrames, mp3.numFrames, mp3.frameLength, key);
        }

        public static void GetMp3Data(Mp3 mp3)
        {
            int i = 0;
            int temp;
            byte[] syncWord = new byte[2] { 0xFF, 0xFB };

            //get mp3 data
            //check for ID3 header
            if (mp3.mp3Bytes[i] == 49 && mp3.mp3Bytes[i + 1] == 44 && mp3.mp3Bytes[i + 2] == 33)
            {
                //find end of ID3 header
                while (mp3.mp3Bytes[i] == syncWord[0] && mp3.mp3Bytes[i + 1] == syncWord[1])
                    i++;
                mp3.dataStart = i;   //get index of where the id3 header ends
            }

            //ensure we are at the start of the mp3 data
            while (mp3.mp3Bytes[i] != syncWord[0] || mp3.mp3Bytes[i + 1] != syncWord[1])
                i++;
            mp3.dataStart = i;

            //get the mp3 header
            mp3.frameHeader[0] = mp3.mp3Bytes[i];
            mp3.frameHeader[1] = mp3.mp3Bytes[++i];
            mp3.frameHeader[2] = mp3.mp3Bytes[++i];
            mp3.frameHeader[3] = mp3.mp3Bytes[++i];
            mp3.numFrames++;

            temp = i;
            //count iterations until next header
            while (mp3.mp3Bytes[i + 1] == mp3.frameHeader[0] && mp3.mp3Bytes[i + 2] == mp3.frameHeader[1] && mp3.mp3Bytes[i + 3] == mp3.frameHeader[2] && mp3.mp3Bytes[i + 4] == mp3.frameHeader[3])
            {
                i++;
            }
            mp3.frameLength = i - temp;

            while (i < mp3.mp3Bytes.Length)
            {
                if (mp3.mp3Bytes[i] == mp3.frameHeader[0] && mp3.mp3Bytes[i + 1] == mp3.frameHeader[1] && mp3.mp3Bytes[i + 2] == mp3.frameHeader[2] && mp3.mp3Bytes[i + 3] == mp3.frameHeader[3])
                    mp3.numFrames++;
                i++;
            }
        }

        public static byte[][] GetFrameArray(Mp3 mp3)
        {
            int i = mp3.dataStart; //reset iterator to start of first header
            byte[][] frames = new byte[mp3.numFrames][];
            byte[] frame = new byte[mp3.frameLength];
            int f = 0; //frame tracker

            //iterate through mp3 again to collect all the frames into an array
            while (i < mp3.mp3Bytes.Length)
            {
                //skip header if at header
                if (mp3.mp3Bytes[i] == mp3.frameHeader[0] && mp3.mp3Bytes[i + 1] == mp3.frameHeader[1] && mp3.mp3Bytes[i + 2] == mp3.frameHeader[2] && mp3.mp3Bytes[i + 3] == mp3.frameHeader[3])
                    i = i + 4;

                //get frame
                for (int j = 0; i < mp3.frameLength; j++)
                {
                    frame[j] = mp3.mp3Bytes[i];
                    i++;
                }

                frames[f] = frame;
                f++;
            }

            return frames;
        }

        //Fisher-Yates shuffling function for a 2D array
        //shuffles using a list of random numbers generated by a key so that it may be unshuffled later
        public static byte[][] Shuffle(byte[][] arr, int numRows, int numCols, int key)
        {
            byte[][] returnArr = arr;
            var shuffles = GetShuffles(numRows, key); //list of shuffles to make
            int shuffle;
            byte[] temp;
            //int j;

            //iterate through, shuffling through the array
            for (int i = numRows - 1; i > 0; i--)
            {
                shuffle = shuffles[numRows - 1 - i]; //get next shuffle position
                //shuffle
                temp = returnArr[i];
                returnArr[i] = returnArr[shuffle];
                returnArr[shuffle] = temp;
            }

            return returnArr;
        }

        //Fisher-Yates unshuffling function for a 2D array
        //unshuffles using a list of random numbers generated by the key that it was shuffled with
        public static byte[][] Unshuffle(byte[][] arr, int numRows, int numCols, int key)
        {
            byte[][] returnArr = arr;
            var shuffles = GetShuffles(numRows, key); //list of shuffles to make to get to original
            int shuffle;
            byte[] temp;

            //iterate through, unshuffling through the array - iterates oppposite to shuffling
            for (int i = 1; i < numRows; i++)
            {
                shuffle = shuffles[numRows - i - 1]; //get next shuffle position
                //unshuffle
                temp = returnArr[i];
                returnArr[i] = returnArr[shuffle];
                returnArr[shuffle] = temp;
            }

            return returnArr;
        }

        //function to get a list of shuffles to make given a key,
        //this is used to ensure the both the shuffling and unshuffling functions generate the same list of shuffles
        public static int[] GetShuffles(int numRows, int key)
        {
            int[] shuffles = new int[numRows - 1];
            var rand = new Random(key); //random number gen, given key
            int r;

            //fill the shuffles array such that it will have (numRows - 1) elements so there are enough for a perfect shuffle
            for (int i = numRows - 1; i > 0; i--)
            {
                r = rand.Next(i + 1);
                shuffles[numRows - 1 - i] = r;
            }

            return shuffles;
        }
    }
}
